{"ast":null,"code":"// Service de notifications croisées entre les deux utilisateurs du couple\nimport notificationService from './notificationService';\nclass CrossNotificationService {\n  constructor() {\n    this.isPolling = false;\n    this.pollingInterval = null;\n    this.lastChecked = Date.now();\n    this.notificationHistory = new Set(); // Pour éviter les doublons\n  }\n\n  // Démarrer le système de notifications croisées\n  async startCrossNotifications() {\n    if (this.isPolling) return;\n\n    // Initialiser les notifications PWA\n    await notificationService.init();\n    this.isPolling = true;\n    this.lastChecked = Date.now();\n\n    // Vérifier les nouvelles activités toutes les 30 secondes\n    this.pollingInterval = setInterval(() => {\n      this.checkForNewActivity();\n    }, 30000);\n    console.log('🔔 Système de notifications croisées démarré');\n  }\n\n  // Arrêter le système\n  stopCrossNotifications() {\n    if (this.pollingInterval) {\n      clearInterval(this.pollingInterval);\n      this.pollingInterval = null;\n    }\n    this.isPolling = false;\n    console.log('🔕 Système de notifications croisées arrêté');\n  }\n\n  // Vérifier les nouvelles activités depuis la dernière vérification\n  async checkForNewActivity() {\n    try {\n      const now = Date.now();\n      const timeSince = new Date(this.lastChecked);\n\n      // Récupérer l'utilisateur actuel\n      const currentUser = JSON.parse(localStorage.getItem('us_user') || '{}');\n      if (!currentUser._id) return;\n\n      // Vérifier les nouveaux rappels\n      await this.checkNewReminders(currentUser._id, timeSince);\n\n      // Vérifier les nouveaux items de wishlist\n      await this.checkNewWishlistItems(currentUser._id, timeSince);\n\n      // Vérifier les nouvelles activités\n      await this.checkNewActivities(currentUser._id, timeSince);\n\n      // Vérifier les nouveaux restaurants\n      await this.checkNewRestaurants(currentUser._id, timeSince);\n      this.lastChecked = now;\n    } catch (error) {\n      console.error('Erreur lors de la vérification des nouvelles activités:', error);\n    }\n  }\n\n  // Vérifier les nouveaux rappels ajoutés par le/la partenaire\n  async checkNewReminders(currentUserId, since) {\n    try {\n      const {\n        reminderService\n      } = await import('./authService');\n      const reminders = await reminderService.getAll();\n      const newReminders = reminders.filter(reminder => {\n        const createdAt = new Date(reminder.created_at);\n        const notificationId = `reminder_${reminder._id}`;\n        return createdAt > since && reminder.created_by !== currentUserId && !this.notificationHistory.has(notificationId);\n      });\n      for (const reminder of newReminders) {\n        const notificationId = `reminder_${reminder._id}`;\n        await this.notifyPartnerActivity('reminder', reminder);\n        this.notificationHistory.add(notificationId);\n      }\n    } catch (error) {\n      console.error('Erreur vérification rappels:', error);\n    }\n  }\n\n  // Vérifier les nouveaux items de wishlist\n  async checkNewWishlistItems(currentUserId, since) {\n    try {\n      const {\n        wishlistService\n      } = await import('./authService');\n      const wishlistItems = await wishlistService.getAll();\n      const newItems = wishlistItems.filter(item => {\n        const createdAt = new Date(item.created_at);\n        const notificationId = `wishlist_${item._id}`;\n        return createdAt > since && item.created_by !== currentUserId && !this.notificationHistory.has(notificationId);\n      });\n      for (const item of newItems) {\n        const notificationId = `wishlist_${item._id}`;\n        await this.notifyPartnerActivity('wishlist', item);\n        this.notificationHistory.add(notificationId);\n      }\n    } catch (error) {\n      console.error('Erreur vérification wishlist:', error);\n    }\n  }\n\n  // Vérifier les nouvelles activités\n  async checkNewActivities(currentUserId, since) {\n    try {\n      const {\n        activityService\n      } = await import('./authService');\n      const activities = await activityService.getAll();\n      const newActivities = activities.filter(activity => {\n        const createdAt = new Date(activity.created_at);\n        const notificationId = `activity_${activity._id}`;\n        return createdAt > since && activity.created_by !== currentUserId && !this.notificationHistory.has(notificationId);\n      });\n      for (const activity of newActivities) {\n        const notificationId = `activity_${activity._id}`;\n        await this.notifyPartnerActivity('activity', activity);\n        this.notificationHistory.add(notificationId);\n      }\n    } catch (error) {\n      console.error('Erreur vérification activités:', error);\n    }\n  }\n\n  // Vérifier les nouveaux restaurants\n  async checkNewRestaurants(currentUserId, since) {\n    try {\n      const {\n        restaurantService\n      } = await import('./authService');\n      const restaurants = await restaurantService.getAll();\n      const newRestaurants = restaurants.filter(restaurant => {\n        const createdAt = new Date(restaurant.created_at);\n        const notificationId = `restaurant_${restaurant._id}`;\n        return createdAt > since && restaurant.created_by !== currentUserId && !this.notificationHistory.has(notificationId);\n      });\n      for (const restaurant of newRestaurants) {\n        const notificationId = `restaurant_${restaurant._id}`;\n        await this.notifyPartnerActivity('restaurant', restaurant);\n        this.notificationHistory.add(notificationId);\n      }\n    } catch (error) {\n      console.error('Erreur vérification restaurants:', error);\n    }\n  }\n\n  // Envoyer la notification selon le type d'activité\n  async notifyPartnerActivity(type, data) {\n    if (!notificationService.isEnabled()) return;\n    let title, body, icon, url;\n    switch (type) {\n      case 'reminder':\n        title = '📝 Nouveau rappel';\n        body = `Ton/ta partenaire a ajouté: \"${data.title}\"`;\n        icon = '📝';\n        url = '/rappels';\n        break;\n      case 'wishlist':\n        title = '🎁 Nouvel item wishlist';\n        body = `Ton/ta partenaire veut: \"${data.title}\"`;\n        icon = '🎁';\n        url = '/wishlist';\n        break;\n      case 'activity':\n        title = '🎯 Nouvelle activité';\n        body = `Ton/ta partenaire a ajouté: \"${data.title}\"`;\n        icon = '🎯';\n        url = '/activites';\n        break;\n      case 'restaurant':\n        title = '🍽️ Nouveau restaurant';\n        body = `Ton/ta partenaire a ajouté: \"${data.name}\"`;\n        icon = '🍽️';\n        url = '/restaurants';\n        break;\n      default:\n        return;\n    }\n    const options = {\n      body,\n      icon: '/favicon.ico',\n      data: {\n        type: `partner_${type}`,\n        itemId: data._id,\n        url\n      },\n      actions: [{\n        action: 'view',\n        title: 'Voir',\n        icon: '/favicon.ico'\n      }, {\n        action: 'dismiss',\n        title: 'OK',\n        icon: '/favicon.ico'\n      }],\n      requireInteraction: false,\n      vibrate: [100, 50, 100]\n    };\n    await notificationService.showNotification(title, options);\n  }\n\n  // Forcer une vérification immédiate (à appeler après création d'un item)\n  async triggerImmediateCheck() {\n    if (this.isPolling) {\n      await this.checkForNewActivity();\n    }\n  }\n\n  // Obtenir le statut du service\n  getStatus() {\n    return {\n      isPolling: this.isPolling,\n      lastChecked: this.lastChecked,\n      notificationHistory: this.notificationHistory.size,\n      isNotificationEnabled: notificationService.isEnabled()\n    };\n  }\n}\n\n// Instance singleton\nconst crossNotificationService = new CrossNotificationService();\nexport default crossNotificationService;","map":{"version":3,"names":["notificationService","CrossNotificationService","constructor","isPolling","pollingInterval","lastChecked","Date","now","notificationHistory","Set","startCrossNotifications","init","setInterval","checkForNewActivity","console","log","stopCrossNotifications","clearInterval","timeSince","currentUser","JSON","parse","localStorage","getItem","_id","checkNewReminders","checkNewWishlistItems","checkNewActivities","checkNewRestaurants","error","currentUserId","since","reminderService","reminders","getAll","newReminders","filter","reminder","createdAt","created_at","notificationId","created_by","has","notifyPartnerActivity","add","wishlistService","wishlistItems","newItems","item","activityService","activities","newActivities","activity","restaurantService","restaurants","newRestaurants","restaurant","type","data","isEnabled","title","body","icon","url","name","options","itemId","actions","action","requireInteraction","vibrate","showNotification","triggerImmediateCheck","getStatus","size","isNotificationEnabled","crossNotificationService"],"sources":["C:/Users/sorbo/US/us-app/frontend/src/services/crossNotificationService.js"],"sourcesContent":["// Service de notifications croisées entre les deux utilisateurs du couple\r\nimport notificationService from './notificationService';\r\n\r\nclass CrossNotificationService {\r\n  constructor() {\r\n    this.isPolling = false;\r\n    this.pollingInterval = null;\r\n    this.lastChecked = Date.now();\r\n    this.notificationHistory = new Set(); // Pour éviter les doublons\r\n  }\r\n\r\n  // Démarrer le système de notifications croisées\r\n  async startCrossNotifications() {\r\n    if (this.isPolling) return;\r\n    \r\n    // Initialiser les notifications PWA\r\n    await notificationService.init();\r\n    \r\n    this.isPolling = true;\r\n    this.lastChecked = Date.now();\r\n    \r\n    // Vérifier les nouvelles activités toutes les 30 secondes\r\n    this.pollingInterval = setInterval(() => {\r\n      this.checkForNewActivity();\r\n    }, 30000);\r\n    \r\n    console.log('🔔 Système de notifications croisées démarré');\r\n  }\r\n\r\n  // Arrêter le système\r\n  stopCrossNotifications() {\r\n    if (this.pollingInterval) {\r\n      clearInterval(this.pollingInterval);\r\n      this.pollingInterval = null;\r\n    }\r\n    this.isPolling = false;\r\n    console.log('🔕 Système de notifications croisées arrêté');\r\n  }\r\n\r\n  // Vérifier les nouvelles activités depuis la dernière vérification\r\n  async checkForNewActivity() {\r\n    try {\r\n      const now = Date.now();\r\n      const timeSince = new Date(this.lastChecked);\r\n      \r\n      // Récupérer l'utilisateur actuel\r\n      const currentUser = JSON.parse(localStorage.getItem('us_user') || '{}');\r\n      if (!currentUser._id) return;\r\n\r\n      // Vérifier les nouveaux rappels\r\n      await this.checkNewReminders(currentUser._id, timeSince);\r\n      \r\n      // Vérifier les nouveaux items de wishlist\r\n      await this.checkNewWishlistItems(currentUser._id, timeSince);\r\n      \r\n      // Vérifier les nouvelles activités\r\n      await this.checkNewActivities(currentUser._id, timeSince);\r\n      \r\n      // Vérifier les nouveaux restaurants\r\n      await this.checkNewRestaurants(currentUser._id, timeSince);\r\n\r\n      this.lastChecked = now;\r\n    } catch (error) {\r\n      console.error('Erreur lors de la vérification des nouvelles activités:', error);\r\n    }\r\n  }\r\n\r\n  // Vérifier les nouveaux rappels ajoutés par le/la partenaire\r\n  async checkNewReminders(currentUserId, since) {\r\n    try {\r\n      const { reminderService } = await import('./authService');\r\n      const reminders = await reminderService.getAll();\r\n      \r\n      const newReminders = reminders.filter(reminder => {\r\n        const createdAt = new Date(reminder.created_at);\r\n        const notificationId = `reminder_${reminder._id}`;\r\n        \r\n        return createdAt > since && \r\n               reminder.created_by !== currentUserId && \r\n               !this.notificationHistory.has(notificationId);\r\n      });\r\n\r\n      for (const reminder of newReminders) {\r\n        const notificationId = `reminder_${reminder._id}`;\r\n        await this.notifyPartnerActivity('reminder', reminder);\r\n        this.notificationHistory.add(notificationId);\r\n      }\r\n    } catch (error) {\r\n      console.error('Erreur vérification rappels:', error);\r\n    }\r\n  }\r\n\r\n  // Vérifier les nouveaux items de wishlist\r\n  async checkNewWishlistItems(currentUserId, since) {\r\n    try {\r\n      const { wishlistService } = await import('./authService');\r\n      const wishlistItems = await wishlistService.getAll();\r\n      \r\n      const newItems = wishlistItems.filter(item => {\r\n        const createdAt = new Date(item.created_at);\r\n        const notificationId = `wishlist_${item._id}`;\r\n        \r\n        return createdAt > since && \r\n               item.created_by !== currentUserId && \r\n               !this.notificationHistory.has(notificationId);\r\n      });\r\n\r\n      for (const item of newItems) {\r\n        const notificationId = `wishlist_${item._id}`;\r\n        await this.notifyPartnerActivity('wishlist', item);\r\n        this.notificationHistory.add(notificationId);\r\n      }\r\n    } catch (error) {\r\n      console.error('Erreur vérification wishlist:', error);\r\n    }\r\n  }\r\n\r\n  // Vérifier les nouvelles activités\r\n  async checkNewActivities(currentUserId, since) {\r\n    try {\r\n      const { activityService } = await import('./authService');\r\n      const activities = await activityService.getAll();\r\n      \r\n      const newActivities = activities.filter(activity => {\r\n        const createdAt = new Date(activity.created_at);\r\n        const notificationId = `activity_${activity._id}`;\r\n        \r\n        return createdAt > since && \r\n               activity.created_by !== currentUserId && \r\n               !this.notificationHistory.has(notificationId);\r\n      });\r\n\r\n      for (const activity of newActivities) {\r\n        const notificationId = `activity_${activity._id}`;\r\n        await this.notifyPartnerActivity('activity', activity);\r\n        this.notificationHistory.add(notificationId);\r\n      }\r\n    } catch (error) {\r\n      console.error('Erreur vérification activités:', error);\r\n    }\r\n  }\r\n\r\n  // Vérifier les nouveaux restaurants\r\n  async checkNewRestaurants(currentUserId, since) {\r\n    try {\r\n      const { restaurantService } = await import('./authService');\r\n      const restaurants = await restaurantService.getAll();\r\n      \r\n      const newRestaurants = restaurants.filter(restaurant => {\r\n        const createdAt = new Date(restaurant.created_at);\r\n        const notificationId = `restaurant_${restaurant._id}`;\r\n        \r\n        return createdAt > since && \r\n               restaurant.created_by !== currentUserId && \r\n               !this.notificationHistory.has(notificationId);\r\n      });\r\n\r\n      for (const restaurant of newRestaurants) {\r\n        const notificationId = `restaurant_${restaurant._id}`;\r\n        await this.notifyPartnerActivity('restaurant', restaurant);\r\n        this.notificationHistory.add(notificationId);\r\n      }\r\n    } catch (error) {\r\n      console.error('Erreur vérification restaurants:', error);\r\n    }\r\n  }\r\n\r\n  // Envoyer la notification selon le type d'activité\r\n  async notifyPartnerActivity(type, data) {\r\n    if (!notificationService.isEnabled()) return;\r\n\r\n    let title, body, icon, url;\r\n\r\n    switch (type) {\r\n      case 'reminder':\r\n        title = '📝 Nouveau rappel';\r\n        body = `Ton/ta partenaire a ajouté: \"${data.title}\"`;\r\n        icon = '📝';\r\n        url = '/rappels';\r\n        break;\r\n        \r\n      case 'wishlist':\r\n        title = '🎁 Nouvel item wishlist';\r\n        body = `Ton/ta partenaire veut: \"${data.title}\"`;\r\n        icon = '🎁';\r\n        url = '/wishlist';\r\n        break;\r\n        \r\n      case 'activity':\r\n        title = '🎯 Nouvelle activité';\r\n        body = `Ton/ta partenaire a ajouté: \"${data.title}\"`;\r\n        icon = '🎯';\r\n        url = '/activites';\r\n        break;\r\n        \r\n      case 'restaurant':\r\n        title = '🍽️ Nouveau restaurant';\r\n        body = `Ton/ta partenaire a ajouté: \"${data.name}\"`;\r\n        icon = '🍽️';\r\n        url = '/restaurants';\r\n        break;\r\n        \r\n      default:\r\n        return;\r\n    }\r\n\r\n    const options = {\r\n      body,\r\n      icon: '/favicon.ico',\r\n      data: {\r\n        type: `partner_${type}`,\r\n        itemId: data._id,\r\n        url\r\n      },\r\n      actions: [\r\n        {\r\n          action: 'view',\r\n          title: 'Voir',\r\n          icon: '/favicon.ico'\r\n        },\r\n        {\r\n          action: 'dismiss',\r\n          title: 'OK',\r\n          icon: '/favicon.ico'\r\n        }\r\n      ],\r\n      requireInteraction: false,\r\n      vibrate: [100, 50, 100]\r\n    };\r\n\r\n    await notificationService.showNotification(title, options);\r\n  }\r\n\r\n  // Forcer une vérification immédiate (à appeler après création d'un item)\r\n  async triggerImmediateCheck() {\r\n    if (this.isPolling) {\r\n      await this.checkForNewActivity();\r\n    }\r\n  }\r\n\r\n  // Obtenir le statut du service\r\n  getStatus() {\r\n    return {\r\n      isPolling: this.isPolling,\r\n      lastChecked: this.lastChecked,\r\n      notificationHistory: this.notificationHistory.size,\r\n      isNotificationEnabled: notificationService.isEnabled()\r\n    };\r\n  }\r\n}\r\n\r\n// Instance singleton\r\nconst crossNotificationService = new CrossNotificationService();\r\n\r\nexport default crossNotificationService;"],"mappings":"AAAA;AACA,OAAOA,mBAAmB,MAAM,uBAAuB;AAEvD,MAAMC,wBAAwB,CAAC;EAC7BC,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACC,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;IAC7B,IAAI,CAACC,mBAAmB,GAAG,IAAIC,GAAG,CAAC,CAAC,CAAC,CAAC;EACxC;;EAEA;EACA,MAAMC,uBAAuBA,CAAA,EAAG;IAC9B,IAAI,IAAI,CAACP,SAAS,EAAE;;IAEpB;IACA,MAAMH,mBAAmB,CAACW,IAAI,CAAC,CAAC;IAEhC,IAAI,CAACR,SAAS,GAAG,IAAI;IACrB,IAAI,CAACE,WAAW,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;;IAE7B;IACA,IAAI,CAACH,eAAe,GAAGQ,WAAW,CAAC,MAAM;MACvC,IAAI,CAACC,mBAAmB,CAAC,CAAC;IAC5B,CAAC,EAAE,KAAK,CAAC;IAETC,OAAO,CAACC,GAAG,CAAC,8CAA8C,CAAC;EAC7D;;EAEA;EACAC,sBAAsBA,CAAA,EAAG;IACvB,IAAI,IAAI,CAACZ,eAAe,EAAE;MACxBa,aAAa,CAAC,IAAI,CAACb,eAAe,CAAC;MACnC,IAAI,CAACA,eAAe,GAAG,IAAI;IAC7B;IACA,IAAI,CAACD,SAAS,GAAG,KAAK;IACtBW,OAAO,CAACC,GAAG,CAAC,6CAA6C,CAAC;EAC5D;;EAEA;EACA,MAAMF,mBAAmBA,CAAA,EAAG;IAC1B,IAAI;MACF,MAAMN,GAAG,GAAGD,IAAI,CAACC,GAAG,CAAC,CAAC;MACtB,MAAMW,SAAS,GAAG,IAAIZ,IAAI,CAAC,IAAI,CAACD,WAAW,CAAC;;MAE5C;MACA,MAAMc,WAAW,GAAGC,IAAI,CAACC,KAAK,CAACC,YAAY,CAACC,OAAO,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC;MACvE,IAAI,CAACJ,WAAW,CAACK,GAAG,EAAE;;MAEtB;MACA,MAAM,IAAI,CAACC,iBAAiB,CAACN,WAAW,CAACK,GAAG,EAAEN,SAAS,CAAC;;MAExD;MACA,MAAM,IAAI,CAACQ,qBAAqB,CAACP,WAAW,CAACK,GAAG,EAAEN,SAAS,CAAC;;MAE5D;MACA,MAAM,IAAI,CAACS,kBAAkB,CAACR,WAAW,CAACK,GAAG,EAAEN,SAAS,CAAC;;MAEzD;MACA,MAAM,IAAI,CAACU,mBAAmB,CAACT,WAAW,CAACK,GAAG,EAAEN,SAAS,CAAC;MAE1D,IAAI,CAACb,WAAW,GAAGE,GAAG;IACxB,CAAC,CAAC,OAAOsB,KAAK,EAAE;MACdf,OAAO,CAACe,KAAK,CAAC,yDAAyD,EAAEA,KAAK,CAAC;IACjF;EACF;;EAEA;EACA,MAAMJ,iBAAiBA,CAACK,aAAa,EAAEC,KAAK,EAAE;IAC5C,IAAI;MACF,MAAM;QAAEC;MAAgB,CAAC,GAAG,MAAM,MAAM,CAAC,eAAe,CAAC;MACzD,MAAMC,SAAS,GAAG,MAAMD,eAAe,CAACE,MAAM,CAAC,CAAC;MAEhD,MAAMC,YAAY,GAAGF,SAAS,CAACG,MAAM,CAACC,QAAQ,IAAI;QAChD,MAAMC,SAAS,GAAG,IAAIhC,IAAI,CAAC+B,QAAQ,CAACE,UAAU,CAAC;QAC/C,MAAMC,cAAc,GAAG,YAAYH,QAAQ,CAACb,GAAG,EAAE;QAEjD,OAAOc,SAAS,GAAGP,KAAK,IACjBM,QAAQ,CAACI,UAAU,KAAKX,aAAa,IACrC,CAAC,IAAI,CAACtB,mBAAmB,CAACkC,GAAG,CAACF,cAAc,CAAC;MACtD,CAAC,CAAC;MAEF,KAAK,MAAMH,QAAQ,IAAIF,YAAY,EAAE;QACnC,MAAMK,cAAc,GAAG,YAAYH,QAAQ,CAACb,GAAG,EAAE;QACjD,MAAM,IAAI,CAACmB,qBAAqB,CAAC,UAAU,EAAEN,QAAQ,CAAC;QACtD,IAAI,CAAC7B,mBAAmB,CAACoC,GAAG,CAACJ,cAAc,CAAC;MAC9C;IACF,CAAC,CAAC,OAAOX,KAAK,EAAE;MACdf,OAAO,CAACe,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;IACtD;EACF;;EAEA;EACA,MAAMH,qBAAqBA,CAACI,aAAa,EAAEC,KAAK,EAAE;IAChD,IAAI;MACF,MAAM;QAAEc;MAAgB,CAAC,GAAG,MAAM,MAAM,CAAC,eAAe,CAAC;MACzD,MAAMC,aAAa,GAAG,MAAMD,eAAe,CAACX,MAAM,CAAC,CAAC;MAEpD,MAAMa,QAAQ,GAAGD,aAAa,CAACV,MAAM,CAACY,IAAI,IAAI;QAC5C,MAAMV,SAAS,GAAG,IAAIhC,IAAI,CAAC0C,IAAI,CAACT,UAAU,CAAC;QAC3C,MAAMC,cAAc,GAAG,YAAYQ,IAAI,CAACxB,GAAG,EAAE;QAE7C,OAAOc,SAAS,GAAGP,KAAK,IACjBiB,IAAI,CAACP,UAAU,KAAKX,aAAa,IACjC,CAAC,IAAI,CAACtB,mBAAmB,CAACkC,GAAG,CAACF,cAAc,CAAC;MACtD,CAAC,CAAC;MAEF,KAAK,MAAMQ,IAAI,IAAID,QAAQ,EAAE;QAC3B,MAAMP,cAAc,GAAG,YAAYQ,IAAI,CAACxB,GAAG,EAAE;QAC7C,MAAM,IAAI,CAACmB,qBAAqB,CAAC,UAAU,EAAEK,IAAI,CAAC;QAClD,IAAI,CAACxC,mBAAmB,CAACoC,GAAG,CAACJ,cAAc,CAAC;MAC9C;IACF,CAAC,CAAC,OAAOX,KAAK,EAAE;MACdf,OAAO,CAACe,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;IACvD;EACF;;EAEA;EACA,MAAMF,kBAAkBA,CAACG,aAAa,EAAEC,KAAK,EAAE;IAC7C,IAAI;MACF,MAAM;QAAEkB;MAAgB,CAAC,GAAG,MAAM,MAAM,CAAC,eAAe,CAAC;MACzD,MAAMC,UAAU,GAAG,MAAMD,eAAe,CAACf,MAAM,CAAC,CAAC;MAEjD,MAAMiB,aAAa,GAAGD,UAAU,CAACd,MAAM,CAACgB,QAAQ,IAAI;QAClD,MAAMd,SAAS,GAAG,IAAIhC,IAAI,CAAC8C,QAAQ,CAACb,UAAU,CAAC;QAC/C,MAAMC,cAAc,GAAG,YAAYY,QAAQ,CAAC5B,GAAG,EAAE;QAEjD,OAAOc,SAAS,GAAGP,KAAK,IACjBqB,QAAQ,CAACX,UAAU,KAAKX,aAAa,IACrC,CAAC,IAAI,CAACtB,mBAAmB,CAACkC,GAAG,CAACF,cAAc,CAAC;MACtD,CAAC,CAAC;MAEF,KAAK,MAAMY,QAAQ,IAAID,aAAa,EAAE;QACpC,MAAMX,cAAc,GAAG,YAAYY,QAAQ,CAAC5B,GAAG,EAAE;QACjD,MAAM,IAAI,CAACmB,qBAAqB,CAAC,UAAU,EAAES,QAAQ,CAAC;QACtD,IAAI,CAAC5C,mBAAmB,CAACoC,GAAG,CAACJ,cAAc,CAAC;MAC9C;IACF,CAAC,CAAC,OAAOX,KAAK,EAAE;MACdf,OAAO,CAACe,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;IACxD;EACF;;EAEA;EACA,MAAMD,mBAAmBA,CAACE,aAAa,EAAEC,KAAK,EAAE;IAC9C,IAAI;MACF,MAAM;QAAEsB;MAAkB,CAAC,GAAG,MAAM,MAAM,CAAC,eAAe,CAAC;MAC3D,MAAMC,WAAW,GAAG,MAAMD,iBAAiB,CAACnB,MAAM,CAAC,CAAC;MAEpD,MAAMqB,cAAc,GAAGD,WAAW,CAAClB,MAAM,CAACoB,UAAU,IAAI;QACtD,MAAMlB,SAAS,GAAG,IAAIhC,IAAI,CAACkD,UAAU,CAACjB,UAAU,CAAC;QACjD,MAAMC,cAAc,GAAG,cAAcgB,UAAU,CAAChC,GAAG,EAAE;QAErD,OAAOc,SAAS,GAAGP,KAAK,IACjByB,UAAU,CAACf,UAAU,KAAKX,aAAa,IACvC,CAAC,IAAI,CAACtB,mBAAmB,CAACkC,GAAG,CAACF,cAAc,CAAC;MACtD,CAAC,CAAC;MAEF,KAAK,MAAMgB,UAAU,IAAID,cAAc,EAAE;QACvC,MAAMf,cAAc,GAAG,cAAcgB,UAAU,CAAChC,GAAG,EAAE;QACrD,MAAM,IAAI,CAACmB,qBAAqB,CAAC,YAAY,EAAEa,UAAU,CAAC;QAC1D,IAAI,CAAChD,mBAAmB,CAACoC,GAAG,CAACJ,cAAc,CAAC;MAC9C;IACF,CAAC,CAAC,OAAOX,KAAK,EAAE;MACdf,OAAO,CAACe,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;IAC1D;EACF;;EAEA;EACA,MAAMc,qBAAqBA,CAACc,IAAI,EAAEC,IAAI,EAAE;IACtC,IAAI,CAAC1D,mBAAmB,CAAC2D,SAAS,CAAC,CAAC,EAAE;IAEtC,IAAIC,KAAK,EAAEC,IAAI,EAAEC,IAAI,EAAEC,GAAG;IAE1B,QAAQN,IAAI;MACV,KAAK,UAAU;QACbG,KAAK,GAAG,mBAAmB;QAC3BC,IAAI,GAAG,gCAAgCH,IAAI,CAACE,KAAK,GAAG;QACpDE,IAAI,GAAG,IAAI;QACXC,GAAG,GAAG,UAAU;QAChB;MAEF,KAAK,UAAU;QACbH,KAAK,GAAG,yBAAyB;QACjCC,IAAI,GAAG,4BAA4BH,IAAI,CAACE,KAAK,GAAG;QAChDE,IAAI,GAAG,IAAI;QACXC,GAAG,GAAG,WAAW;QACjB;MAEF,KAAK,UAAU;QACbH,KAAK,GAAG,sBAAsB;QAC9BC,IAAI,GAAG,gCAAgCH,IAAI,CAACE,KAAK,GAAG;QACpDE,IAAI,GAAG,IAAI;QACXC,GAAG,GAAG,YAAY;QAClB;MAEF,KAAK,YAAY;QACfH,KAAK,GAAG,wBAAwB;QAChCC,IAAI,GAAG,gCAAgCH,IAAI,CAACM,IAAI,GAAG;QACnDF,IAAI,GAAG,KAAK;QACZC,GAAG,GAAG,cAAc;QACpB;MAEF;QACE;IACJ;IAEA,MAAME,OAAO,GAAG;MACdJ,IAAI;MACJC,IAAI,EAAE,cAAc;MACpBJ,IAAI,EAAE;QACJD,IAAI,EAAE,WAAWA,IAAI,EAAE;QACvBS,MAAM,EAAER,IAAI,CAAClC,GAAG;QAChBuC;MACF,CAAC;MACDI,OAAO,EAAE,CACP;QACEC,MAAM,EAAE,MAAM;QACdR,KAAK,EAAE,MAAM;QACbE,IAAI,EAAE;MACR,CAAC,EACD;QACEM,MAAM,EAAE,SAAS;QACjBR,KAAK,EAAE,IAAI;QACXE,IAAI,EAAE;MACR,CAAC,CACF;MACDO,kBAAkB,EAAE,KAAK;MACzBC,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE,EAAE,GAAG;IACxB,CAAC;IAED,MAAMtE,mBAAmB,CAACuE,gBAAgB,CAACX,KAAK,EAAEK,OAAO,CAAC;EAC5D;;EAEA;EACA,MAAMO,qBAAqBA,CAAA,EAAG;IAC5B,IAAI,IAAI,CAACrE,SAAS,EAAE;MAClB,MAAM,IAAI,CAACU,mBAAmB,CAAC,CAAC;IAClC;EACF;;EAEA;EACA4D,SAASA,CAAA,EAAG;IACV,OAAO;MACLtE,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBE,WAAW,EAAE,IAAI,CAACA,WAAW;MAC7BG,mBAAmB,EAAE,IAAI,CAACA,mBAAmB,CAACkE,IAAI;MAClDC,qBAAqB,EAAE3E,mBAAmB,CAAC2D,SAAS,CAAC;IACvD,CAAC;EACH;AACF;;AAEA;AACA,MAAMiB,wBAAwB,GAAG,IAAI3E,wBAAwB,CAAC,CAAC;AAE/D,eAAe2E,wBAAwB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}